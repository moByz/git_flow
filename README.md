# Удачная модель ветвления для Git
## https://habr.com/ru/post/106912/
## Главные ветви:
* master
* develop
## Вспомогательные ветви 
```
1. Ветви функциональностей (feature branches) - предназначены для реализации некого функционала, который появится в будующих релизах.
2. Ветви релизов (release branches) - предназначены для подготовки выпуска новых версий продукта.
3. Ветви исправлений (hotfix branches) - порождаются необходимостью немедленно исправить нежелательное поведение производственной версии продукта.
```
## Ветви функциональностей 
* Порождаются от develop и вливаются в develop.
* Соглашение о именовании - всё, за исключением master, develop, release-* или hotfix-*
### Создание ветви функциональностей
```
git checkout -b myfeature develop - создаем ветку myfeature от ветви develop.
```
### Добавление завершенной функциональности в develop
```
git checkout develop - переходим в ветку develop.
git merge --no-ff myfeature - вливаем ветку myfeature в ветку develop.
git branch -d myfeature - удаляем ветку myfeature.
git push origin develop - пушим изменения в удаленную ветку develop.
```
## Ветви релизов
* Порождаются от develop.
* Вливаются в develop или master.
* Соглашение о наименовании: release-*
### Когда порождать ветви релиза
* Новую ветку релиза (release branch) надо порождать в тот момент, когда состояние ветви разработки полностью или почти полностью соответствует требованиям, соответствующим новому релизу. По крайней мере, вся необходимая функциональность, предназначенная к этому релизу, уже влита в ветвь разработки (develop). Функциональность, предназначенная к следующим релизам, может быть и не влита. Даже лучше, если ветки для этих функциональностей подождут, пока текущая ветвь релиза не отпочкуется от ветви разработки (develop).

* Очередной релиз получает свой номер версии только в тот момент, когда для него создаётся новая ветвь, но ни в коем случае не раньше. Вплоть до этого момента ветвь разработки содержит изменения для «нового релиза», но пока ветка релиза не отделилась, точно неизвестно, будет ли этот релиз иметь версию 0.3, или 1.0, или какую-то другую. Решение принимается при создании новой ветви релиза и зависит от принятых на проекте правил нумерации версий проекта.
### Создание ветви релиза
```
git checkout -b release-1.2 develop - созадем ветвь релиза от ветви dvelop и переключаемся на нее.
git commit -a -m "Bumped version number to 1.2" - добавляем изменения в индекс и коммитим их.
```
### Закрытие ветви релиза
```
git checkout master - переключаемся в ветвь master.
git merge --no-ff release-1.2 - вливаем ветвь релиза в мастер.
git tag -a 1.2 - создаем тег релиза, чтобы потом можно было легко найти нужный релиз.
git branch -d release-1.2 - удаляем ветвь релиза, т.к. она больше не нужна.
```
## Ветви исправлений
* Порождаются от master
* Вливаются в develop и master
* Соглашение о наименовании: hotfix-*
### Создание ветви исправлений 
```
git checkout -b hotfix-1.2.1 master - создаем ветку для исправления бага от ветки master и переключаемся на нее.
git commit -a -m "Bumped version number to 1.2.1" - добавляем файлы в индекс и коммитим их.
После проделанных команд можно исправлять баг.
```
### Закрытие ветви исправлнеий
```
git checkout master - переходим в ветку master.
git merge --no-ff hotfix-1.2.1 - сливаем ветку master с веткой hotfix-1.2.1
git tag -a 1.2.1 - добавляем тег версии.

git checkout develop - переходим в ветвь develop.
git merge --no-ff hotfix-1.2.1 - сливаем ветку develop c веткой hotfix-1.2.1
!!! Исключение: если существует ветвь релиза, то изменения должны вливаться в нее, а не в develop.
git branch -d hotfix-1.2.1 - удаляем ветку hotfix-1.2.1 
```
